user nobody;
worker_processes auto;
# Use OpenResty's default log directory so files exist in the container
error_log /dev/stderr info;
pid /usr/local/openresty/nginx/logs/nginx.pid;

include /usr/share/nginx/modules/*.conf;

events {
    worker_connections 1024;
}

http {
    sendfile on;
    tcp_nopush on;
    keepalive_timeout 65;
    # Send logs to container stdout/stderr so `docker logs` shows them
    access_log /dev/stdout;
    error_log /dev/stderr info;

    # Use Docker embedded DNS (kept in case it's useful for variables)
    resolver 127.0.0.11 valid=30s;

    # Note: we do not declare an nginx "upstream" with the "resolve" parameter
    # because this OpenResty build does not support that upstream option and
    # it causes startup errors. The Lua code in the access_by_lua_block
    # performs HTTP requests to Cerbos directly (http://cerbos:3592) and will
    # use the container's DNS resolver at request time.

    # Upstream services
    upstream grafana {
        server grafana:3000;
    }

    # MinIO proxy removed - this nginx only proxies Grafana (protected by Cerbos)

    server {
        listen 80;
        server_name localhost;

        # ----------------------------
        # ðŸ”’ GRAFANA (Protected by Cerbos)
        # ----------------------------
        location /grafana/ {
            # Rewrite URL for Grafana internal routing
            rewrite ^/grafana/(.*)$ /$1 break;

            # --- Cerbos Authorization Check ---
            access_by_lua_block {
                local http = require "resty.http"
                local cjson = require "cjson.safe"
                local httpc = http.new()

                -- Prefer explicit headers for testing: X-User-Id and X-User-Role
                local user_role = ngx.var.http_x_user_role or ngx.req.get_headers()["x-user-role"] or "viewer"
                local user_id = ngx.var.http_x_user_id or ngx.req.get_headers()["x-user-id"] or ngx.var.remote_addr or "anonymous"

                                -- include an instances array to satisfy Cerbos validation (instances required)
                                                                local payload = cjson.encode({
                                                                    principal = { id = user_id, roles = { user_role } },
                                                                    -- Cerbos expects resource.instances to be a map of instanceID -> instanceAttrs
                                                                    resource = { kind = "dashboard", instances = { ["grafana"] = {} } },
                                                                    actions = { "view" }
                                                                })

                local res, err = httpc:request_uri("http://cerbos:3592/api/check", {
                    method = "POST",
                    body = payload,
                    headers = { ["Content-Type"] = "application/json" }
                })

                -- Debug: log the payload and Cerbos response for troubleshooting
                ngx.log(ngx.INFO, "cerbos request payload: ", payload)
                if not res then
                    ngx.log(ngx.ERR, "cerbos request failed: ", err or "no response")
                    ngx.status = 403
                    ngx.say("Access denied by Cerbos policy")
                    ngx.exit(403)
                end
                ngx.log(ngx.INFO, "cerbos response status: ", res.status, " body: ", res.body or "")
                if res.status ~= 200 then
                    ngx.log(ngx.ERR, "cerbos returned non-200: ", res.status)
                    ngx.status = 403
                    ngx.say("Access denied by Cerbos policy")
                    ngx.exit(403)
                end

                -- Parse JSON response and check for EFFECT_ALLOW in the result.
                local body = res.body or ""
                local j, perr = cjson.decode(body)
                local allowed = false
                if j then
                    -- Cerbos returns a structure; try to inspect known fields.
                    -- The exact shape may vary; look for an "effect" or similar.
                    if j.result and j.result[1] and j.result[1].effect == "EFFECT_ALLOW" then
                        allowed = true
                    end
                end

                -- Fallback: legacy string matching if JSON shape is unexpected
                if not allowed and body:find("EFFECT_ALLOW") then
                    allowed = true
                end

                if not allowed then
                    ngx.status = 403
                    ngx.say("Access denied by Cerbos authorization")
                    ngx.exit(403)
                end
            }
            # -----------------------------------

            proxy_pass http://grafana;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # MinIO proxy removed - this nginx only proxies Grafana (protected by Cerbos)
    }
}
